## **Vue面试题**

**生命周期函数面试题**

- 1.什么是 vue 生命周期

  vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有的功能都是围绕着其生命周期进行的。

- 2.vue生命周期的作用是什么

  在不同生命周期的不同阶段调用对应的钩子函数来实现组件数据管理和DOM渲染两大重要功能。

- 3.第一次页面加载会触发哪几个钩子

   beforeCreate, created, beforeMount, mounted 

- 4.简述每个周期具体适合哪些场景

   beforecreate : 可以在这加个loading事件，在加载实例时触发 

  created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

  mounted : 挂载元素，获取到DOM节点

  updated : 如果对数据统一处理，在这里写上相应函数

  beforeDestroy : 可以做一个确认停止事件的确认框

  nextTick : 更新数据后立即操作dom

- 5.created和mounted的区别

  created：是在模板渲染成HTML前调用的，此时data已经准备完毕，el仍是undefined，因为没有渲染成HTML，所以不能操作dom节点，它主要用来初始化一些数据；

  mounted：是在模板渲染成HTML之后调用的，此时data，el都已准备好，可以操作html的dom节点，可以通过id什么的来查找页面元素，也可以加载一些组件什么的；

  **即使created中的方法没有执行完，mounted也会被调用！**

- 6.vue获取数据在哪个周期函数

  1. 越早越好（能放created就放created里）
  2. 不要在 updated 里更新数据

- 7.请详细说下你对vue生命周期的理解？

  生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。

  创建前/后： 在beforeCreated阶段，vue实例的**挂载元素**$el和**数据对象**data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。

  载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是**挂载之前**为**虚拟的dom节点**，**data.message**还未替换。在mounted阶段，vue实例挂载完成，**data.message成功渲染**。

  更新前/后：当data变化时，会触发**beforeUpdate和updated**方法。

  销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

**vue路由面试题**

- 1.mvvm 框架是什么？

  M：Model(服务器上的业务逻辑操作)  V：View（页面）VM：ViewModel（Model与View之间核心枢纽，比如Vue.js）

  ![img](https://upload-images.jianshu.io/upload_images/15052797-eaefba8ee30eebee.png?imageMogr2/auto-orient/strip|imageView2/2/w/613/format/webp)

  Model与ViewModel之间的双向关系
   Model通过Ajax通信，发送数据给ViewModel。
   ViewModel也可以通过Ajax通信，发送请求给Model。

  ViewModel与View之间的双向关系
   ViewModel中的数据改变，可以同时改变View上的显示内容。
   View上的内容改变(比如输入框中的内容)，也可以同时改变ViewModel中对应的数据。

- 2.vue-router 是什么?它有哪些组件

  **路由中有三个基本的概念 route, routes, router。**

  1， route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 => home内容， 这是一条route, about按钮 => about 内容， 这是另一条路由。

  2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。

  [{home 按钮 =>home内容 }， { about按钮 => about 内容}]

  3， **router 是一个机制，相当于一个管理者**，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。

  4，客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api.
  路由跳转等都需要vue-router

  ```
  <router-link :to='' class='active-class'>   //路由声明式跳转 ，active-class是标签被点击时的样式
  
  <router-view>                  //渲染路由的容器
  
  <keep-alive>                    //缓存组件
  ```

- 3.active-class 是哪个组件的属性？

  active-class是vue-router模块的router-link组件中的属性，用来做选中样式的切换

- 4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值

  可以通过query ,param两种方式

  区别: query通过url传参，刷新页面还在  params刷新页面不在了

    **params的类型:**

  - 配置路由格式:/router/:id
  - 传递的方式:在path后面跟上对应的值
  -  传递后形成的路径:/router/123

  ```
  <!-- 动态路由-params -->
  //在APP.vue中
  <router-link :to="'/user/'+userId" replace>用户</router-link>    
   
  //在index.js
  {
      path: '/user/:userid',
      component: User,
  },
  ```

  跳转方法:

  ```
  // 方法1：
  <router-link :to="{ name: 'users', params: { uname: wade }}">按钮</router-link>
  // 方法2：
  this.$router.push({name:'users',params:{uname:wade}})
  // 方法3：
  this.$router.push('/user/' + wade)
  ```

  可以通过$route.params.userid 获取你说传递的值

  **query的类类型**

  -  配置路由格式:/router,也就是普通配置
  -  传递的方式:对象中使用query的key作为传递方式
  -  传递后形成的路径:/route?id=123

  ```
  
  <!--动态路由-query -->
  //01-直接在router-link 标签上以对象的形式
  <router-link :to="{path:'/profile',query:{name:'why',age:28,height:188}}">档案</router-link>
  /*
      02-或者写成按钮以点击事件形式
      <button @click='profileClick'>我的</button>    
  */
   
   //点击事件
   profileClick(){
     this.$router.push({
          path: "/profile",
          query: {
            name: "kobi",
            age: "28",
            height: 198
          }
        });
   }
  ```

  跳转方法:

  ```
  // 方法1：
  <router-link :to="{ name: 'users', query: { uname: james }}">按钮</router-link>
  // 方法2：
  this.$router.push({ name: 'users', query:{ uname:james }})
  // 方法3：
  <router-link :to="{ path: '/user', query: { uname:james }}">按钮</router-link>
  // 方法4：
  this.$router.push({ path: '/user', query:{ uname:james }})
  // 方法5：
  this.$router.push('/user?uname=' + jsmes)
  ```

  可以通过$route.query 获取你说传递的值

- 5.vue-router 有哪几种导航钩子?

  1、全局守卫： `router.beforeEach`

  2、全局解析守卫： `router.beforeResolve`

  3、全局后置钩子： `router.afterEach`

  4、路由独享的守卫： `beforeEnter`

  5、组件内的守卫： `beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave`

- 6.route和router 的区别

  1.router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。

  举例：history对象

  $router.push({path:'home'});本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录

  方法：

  $router.replace({path:'home'});//替换路由，没有历史记录

  2.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等

  $route.path 
  字符串，等于当前路由对象的路径，会被解析为绝对路径，如 `"/home/news"` 。

  $route.params 
  对象，包含路由中的动态片段和全匹配片段的键值对

  $route.query 
  对象，包含路由中查询参数的键值对。例如，对于 `/home/news/detail/01?favorite=yes` ，会得到`$route.query.favorite == 'yes'` 。

  $route.router 
  路由规则所属的路由器（以及其所属的组件）。

  $route.matched 
  数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

  $route.name 
  当前路径的名字，如果没有使用具名路径，则名字为空。

  `$route.path, $route.params, $route.name, $route.query`这几个属性很容易理解，主要用于接收路由传递的参数

- 7.vue-router响应路由参数的变化

  当使用路由参数时，例如从 `/user/foo` 导航到 `/user/bar`，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。

  ### 监测路由参数变化的方法

  **方法一watch监听：**

  ```
  watch: { // watch的第一种写法
      $route (to, from) {
          console.log(to)
          console.log(from)
      }
  },
  
  ====
  
  watch: { // watch的第二种写法
      $route: {
          handler (to, from){
              console.log(to)
              console.log(from)
          },
          // 深度观察监听
          deep: true
      }
  },
  
  ====
  
  watch: { // watch的第三种写法
      '$route':'getPath'
  },
  
  methods: {
      getPath(to, from){
          console.log(this.$route.path);
      }
  },
  ```

  **方法二：导航守卫**

  ```
  beforeRouteEnter (to, from, next) {
      console.log('beforeRouteEnter被调用：在渲染该组件的对应路由被 confirm 前调用')
      // 在渲染该组件的对应路由被 confirm 前调用
      // 不！能！获取组件实例 `this` 因为当守卫执行前，组件实例还没被创建
      // 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
      next(vm => {
          // 通过 `vm` 访问组件实例
          console.log(vm)
      })
  },
  // beforeRouteEnter 是支持给 next 传递回调的唯一守卫。
  // 对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。
  beforeRouteUpdate (to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 `this`
      console.log('beforeRouteUpdate被调用：在当前路由改变，但是该组件被复用时调用')
      next()
  },
  beforeRouteLeave (to, from, next) {
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
      const answer = window.confirm('是否确认离开当前页面')
      if (answer) {
          console.log('beforeRouteLeave被调用：导航离开该组件的对应路由时调用')
          next()
      } else {
          next(false)
      }
  },
  ```

- 8.vue-router传参

  vue-router传递参数分为两大类

  - 编程式的导航 router.push
  - 声明式的导航 <router-link>

  ##### 编程式的导航 router.push

  编程式导航传递参数有两种类型：字符串、对象。

  ##### 字符串

  字符串的方式是直接将路由地址以字符串的方式来跳转，这种方式很简单但是不能传递参数：

  ```javascript
  this.$router.push("home");
  ```

  ##### 对象

  想要传递参数主要就是以对象的方式来写，分为两种方式：命名路由、查询参数，下面分别说明两种方式的用法和注意事项。

  ##### 命名路由

  命名路由的前提就是在注册路由的地方需要给路由命名如：
  ![img](https://img-blog.csdn.net/20180706161414540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  命名路由传递参数需要使用params来传递，这里一定要注意使用params不是query。目标 页面接收传递参数时使用params

   特别注意：命名路由这种方式传递的参数，如果在目标页面刷新是会出错的

  使用方法如下：

  ```javascript
  this.$router.push({ name: 'news', params: { userId: 123 }})
  ```

  代码如下：

  ```javascript
  <template>
    <div class="hello">
      <h1>{{ msg }}</h1>
      <button @click="routerTo">click here to news page</button>
    </div>
  </template>
  <script>
  export default {
    name: 'HelloWorld',
    data () {
      return {
        msg: 'Welcome to Your Vue.js App'
      }
    },
    methods:{
      routerTo(){
        this.$router.push({ name: 'news', params: { userId: 123 }});
      }
    }
  }
  </script>
  <style>
  </style>
  ```

  接受传递的参数：

  ```javascript
  <template>
    <div>
      this is the news page.the transform param is {{this.$route.params.userId}}
    </div>
  </template>
  <script>
  </script>
  ```

  运行效果如下：

  ![img](https://img-blog.csdn.net/20180706161655335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  

  ##### 查询参数

  查询参数其实就是在路由地址后面带上参数和传统的url参数一致的，传递参数使用query而且必须配合path来传递参数而不能用name，目标页面接收传递的参数使用query。
  注意：和name配对的是params，和path配对的是query
  使用方法如下：

  ```javascript
  this.$router.push({ path: '/news', query: { userId: 123 }});
  ```

  代码如下：

  ```javascript
  <template>
    <div class="hello">
      <h1>{{ msg }}</h1>
      <button @click="routerTo">click here to news page</button>
    </div>
  </template>
  <script>
  export default {
    name: 'HelloWorld',
    data () {
      return {
        msg: 'Welcome to Your Vue.js App'
      }
    },
    methods:{
      routerTo(){
        this.$router.push({ path: '/news', query: { userId: 123 }});
      }
    }
  }
  </script>
  <style>
  </style>
  ```

  接收参数如下：

  ```javascript
  <template>
    <div>
      this is the news page.the transform param is {{this.$route.query.userId}}
    </div>
  </template>
  <script>
  </script>
  ```

  运行效果如下：

  ![img](https://img-blog.csdn.net/20180706161912678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  

  ##### 声明式的导航

  声明式的导航和编程式的一样，这里就不在过多介绍，给几个例子大家对照编程式理解，例子如下：

  ##### 字符串

  ```html
  <router-link to="news">click to news page</router-link>
  ```

  ##### 命名路由

  ```html
  <router-link :to="{ name: 'news', params: { userId: 1111}}">click to news page</router-link>
  ```

  运行效果如下：
  ![img](https://img-blog.csdn.net/20180706162125975?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  ##### 查询参数

  ```html
  <router-link :to="{ path: '/news', query: { userId: 1111}}">click to news page</router-link>
  ```

  运行效果如下：
  ![img](https://img-blog.csdn.net/2018070616220461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  最后总结：路由传递参数和传统传递参数是一样的，命名路由类似表单提交而查询就是url传递，在vue项目中基本上掌握了这两种传递参数就能应付大部分应用了，最后总结为以下两点：
  1.命名路由搭配params，刷新页面参数会丢失
  2.查询参数搭配query，刷新页面数据不会丢失
  3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值

- 9.vue-router的两种模式

  1：`hash - 即地址栏URL中的 # 符号`（此hash不是密码学里的散列运算）
  比如这个URL：`http：//www.abc.com/#/hello`,hash的值为`#/hello`.它的特点在于：hash虽然出现在URL中，但不会被包括在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。
  2：**history - 利用了HTML5 History Interface中新增的`pushState()和replaceState（）`方法。**（需要特定浏览器支持）

  这两个方法应用于浏览器的**历史记录栈**，在当前已有的`back`、`forward`、`go`的基础上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的URL，但浏览器不会即向后端发送请求。

  因此可以说，hash模式和histoury模式都是属于浏览器自身的特性，Vue-Router只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由

  #### 使用场景

  一般情景下，hash和histoury都可以，除非你更在意颜值，`#`符号夹杂在URL里看起来确实有些不太美丽。如果不想要很丑的hash，我们可以用路由的history模式，这种模式充分利用history。pushState API来完成URL跳转二无须重新加载页面。
  **调用`history.pushState()`相比于直接修改`hash` ，存在以下优势：**
  1：`pushState()`设置的新URL可以是与当前URL同源的任意URL；而`hash`只可修改`#`后面的部分，因此只能设置与当前URL同文档的URL；
  2：`pushState()`设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而`hash`设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
  3：`pushState()`通过stateObject参数可以添加任意类型的数据到记录中；而`hash`只可添加短字符串；
  4：`pushState()`可额外设置title属性供后续使用。

  当然`history`也不是样样都好。SPA虽然在浏览器里游刃有余，单真要通过URL向后端发起HTTP请求时，两者的差异就来了。尤其在用户手动输入URL后回车，或者刷新（重启）浏览器的时候。
  1：`hash` 模式下，仅hash符号之前的内容会被包含在请求中，如`http://www.abc.com`,因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误。
  2：`history`模式下，前端的URL必须和实际向后端发起请求的URL一致。如`htttp://www.abc.com/book/id`。如果后端缺少对/book/id 的路由处理，将返回404错误

- 10.vue-router实现路由懒加载（ 动态加载路由 ）

  ##### 1、定义

  　　也叫延迟加载，即在需要的时候进行加载，随用随载

  ##### 2、为什么需要

  　　像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时，进入首页不用一次加载过多资源造成用时过长。

  ##### 3、如何实现？

  （1）第一种写法：使用 AMD 风格的 require，于是就更简单了：

  ```
  例：const Foo = resolve => require(['./Foo.vue'], resolve)
  ```

  ```
  const routers = [
      {
          path: '/',
          name: 'index',
          component: (resolve) => require(['./views/index.vue'], resolve)
      }
  ]
  ```

  （2）第二种写法：(使用import)

  ```
  例：component: () => import('@/components/Two')
  ```

  ```
  const Index = () => import(/* webpackChunkName: "group-home" */  '@/views/index')
  const routers = [
      {
          path: '/',
          name: 'index',
          component: Index
      }
  ]
  ```

  （3）第三种写法：使用webpack特有的require.ensure()。注：require.ensure 是 Webpack 的特殊语法，用来设置 code-split point

  ```
  例：components: r => require.ensure([], () => r(require('@/components/Three')), 'group-home')
  ```

  ```
  const Index = r => require.ensure([], () => r(require('./views/index')), 'group-home');
  const routers = [
      {
          path: '/',
          name: 'index',
          component: Index
      }
  ]
  ```

  ##### 4、把组件按组分块

  有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 [命名 chunk](https://webpack.js.org/guides/code-splitting-require/#chunkname)，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。

  ```
  const Foo = r => require.ensure([], () => r(require('./Foo.vue')), 'group-foo')
  const Bar = r => require.ensure([], () => r(require('./Bar.vue')), 'group-foo')
  const Baz = r => require.ensure([], () => r(require('./Baz.vue')), 'group-foo')
  const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')
  const Bar = () => import(/* webpackChunkName: "group-foo" */ './Bar.vue')
  const Baz = () => import(/* webpackChunkName: "group-foo" */ './Baz.vue')
  ```

  Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。

  ##### 5、注

  - 一般常用第二种简写
  - 第三种中，’group-home’是把组件按组分块打包, 可以将多个组件放入这个组中，在打包的时候Webpack会将相同 chunk 下的所有异步模块打包到一个异步块里面。

**vue常见面试题**

- 1.vue优点

  **1、轻量级框架**

  只关注视图层,是一个构建数据的视图集合,大小只有几十kb

  Vue.js通过简洁的API提供高效的数据绑定和灵活的组件系统

  **2、简单易学**

  国人开发,中文文档,不存在语言障碍,易于理解和学习

  **3、双向数据绑定**

  也就是所谓的响应式数据绑定。这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出同步的响应。

  也就是说，vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，就是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。

  这也就是vue.js最大的优点，通过MVVM思想实现数据的双向绑定，让开发者不用再操作dom对象，有更多的时间去思考业务逻辑。

  **4、组件化**

  在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。

  Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。

  **5、视图,数据,结构分离**

  使数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作

  **6、虚拟DOM**

  现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。

  而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。

  **7、运行速度更快**

  像比较与react而言,同样都是操作虚拟dom,就性能而言,vue存在很大的优势

- 2.vue父组件向子组件传递数据？

   1.父组件调用子组件的时候 绑定动态属性

   2.在子组件里面通过 props接收父组件传过来的数据

   3.直接在子组件里面使用

- 3.子组件向父组件传递事件

  子组件：

  ```
  <template>
      <div class="app">
         <input @click="sendMsg" type="button" value="给父组件传递值">
      </div>
  </template>
  <script>
  export default {
      data () {
          return {
              //将msg传递给父组件
              msg: "我是子组件的msg",
          }
      },
       methods:{
           sendMsg(){
               //func: 是父组件指定的传数据绑定的函数，this.msg:子组件给父组件传递的数据
               this.$emit('func',this.msg)
           }
       }
  }
  </script>
  ```

  子组件通过**this.$emit()**的方式将值传递给父组件

  **注意：**这里的func是父组件中绑定的函数名

  父组件：

  ```
  <template>
      <div class="app">
          <child @func="getMsgFormSon"></child>
      </div>
  </template>
  <script>
  import child from './child.vue'
  export default {
      data () {
          return {
              msgFormSon: "this is msg"
          }
      },
      components:{
          child,
      },
      methods:{
              getMsgFormSon(data){
                  this.msgFormSon = data
                  console.log(this.msgFormSon)
              }
      }
  }
  </script>
  ```

- 4.v-show和v-if指令的共同点和不同点

  **v-if和v-show的相同点：**

  - 都能够实现指定内容的显示和隐藏操作的效果

  **v-if和v-show的不同点：**

  - v-if在每次完成显示和隐藏功能时，需要不断的在dom树上完成节点的创建和删除操作
  - v-show则直接通过修改display样式的属性值来完成。

- 5.如何让CSS只在当前组件中起作用

  当前组件<style>写成<style scoped>

- 6.？？？？？的作用是什么?

- 7.vue中如何获取dom？

   #### 使用DOM API直接找元素

   ```javascript
   <script>
   	...
   	mounted () {
   		let elm = this.$el.querySelector('#id')
   	}
   </script>
   ```

   这种方法足够简单直观，Vue组件在patch阶段结束时会把`this.$el`赋值为挂载的根dom元素，我们可以直接使用`$el`的`querySelector, querySelectorAll`等方法获取匹配的元素。

   #### refs

   ```javascript
   <template>
   	<div ref="bar">{{ foo }}</div>
   	<MyAvatar ref="avatar" />
   	...
   </template>
   <script>
   	...
   	mounted () {
   		let foo = this.$refs['bar'] // 一个dom元素
   		let avatar = this.$refs['avatar'] // 一个组件实例对象
   	}
   </script>
   ```

   使用组件实例的`$refs`即可拿到组件上`ref`属性对应的元素。
   如果ref属性加在一个组件上，那么拿到的是这个组件的实例，否则拿到的就是dom元素了。

   值得注意的是包含`v-for`循环模板指令的情况，其循环元素和子元素上`ref`属性对应的都是一个数组（就算动态生成ref，也是数组）：

   ```javascript
   <template>
   	<div v-for="item in qlist" :key="item.id" ref="qitem">
   		<h3>{{ item.title  }}</h3>
   		<p ref="pinitem">{{ item.desc }}</p>
   		<p :ref="'contact'+item.id">{{ item.contact }}</p>
   	</div>
   	...
   </template>
   <script>
   	...
   	data () {
   		return {
   			qlist: [
   				{ id: 10032, title: 'abc', desc: 'aadfdcc', contact: 123 },
   				{ id: 11031, title: 'def', desc: '--*--', contact: 856 },
   				{ id: 20332, title: 'ghi', desc: '?/>,<{]', contact: 900 }
   			]
   		}
   	},
   	mounted () {
   		let foo = this.$refs['qitem'] // 一个包含dom元素的数组
   		let ps = this.$refs['pinitem'] // p元素是v-for的子元素，同样是一个数组
   		let contact1 = this.$refs['contact' + this.qlist[0].id] // 还是个数组
   	}
   </script>
   ```

   关于这个的原因，可以从Vue关于ref处理的部分代码得到：

   ```javascript
   function registerRef (vnode, isRemoval) {
     var key = vnode.data.ref;
     if (!isDef(key)) { return }
   
     var vm = vnode.context;
     // vnode如果有componentInstance表明是一个组件vnode，它的componentInstance属性是其真实的根元素vm
     // vnode如果没有componentInstance则不是组件vnode，是实际元素vnode，直接取其根元素
     var ref = vnode.componentInstance || vnode.elm;
     var refs = vm.$refs;
     if (isRemoval) {
       ...
     } else {
     	// refInFor是模板编译阶段生成的，它是一个布尔值，为true表明此vnode在v-for中
       if (vnode.data.refInFor) {
         if (!Array.isArray(refs[key])) {
           refs[key] = [ref]; // 就算元素唯一，也会被处理成数组
         } else if (refs[key].indexOf(ref) < 0) {
           // $flow-disable-line
           refs[key].push(ref);
         }
       } else {
         refs[key] = ref;
       }
     }
   }
   ```

   #### 使用自定义指令

   Vue提供了自定义指令，官方文档给出了如下的使用方法，其中`el`就是dom元素的引用

   ```javascript
   Vue.directive('focus', {
     // 当被绑定的元素插入到 DOM 中时……
     inserted: function (el) {
       // 聚焦元素
       el.focus()
     }
   })
   
   // 在模板中
   <template>
   	<input v-model="name" v-focus />
   </template>
   ```

- 8.说出几种vue当中的指令和它的用法？

   v-once: 只绑定一次

   v-bind: 绑定数据

   v-model: 绑定模型

   v-on: 绑定事件

   v-if v-show: 条件渲染

- 9.vue-loader是什么？使用它的用途有哪些？

   Vue Loader 是一个 webpack 的 loader，它允许你以一种名为[单文件组件 (SFCs)]的格式撰写 Vue 组件：

   - 允许为 Vue 组件的每个部分使用其它的 webpack loader，例如在 `<style>` 的部分使用 Sass 和在 `<template>` 的部分使用 Pug（一个模板引擎）；
   - 允许在一个 `.vue` 文件中使用自定义块，并对其运用自定义的 loader 链；
   - 使用 webpack loader 将 `<style>` 和 `<template>` 中引用的资源当作模块依赖来处理；
   - 为每个组件模拟出 scoped CSS；
   - 在开发过程中使用热重载来保持状态。

- 10.为什么使用key

   因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM

- 11.axios及安装

   使用npm安装

   ```
   npm install axios
   ```

   main.js:导入

   ```
   import axios from 'axios'
   Vue.prototype.$http = axios
   Vue.prototype.$http.defaults.baseURL = '' // baseURL 将自动加在url前面，除非url是一个绝对URL
   ```

- 12.axios解决跨域

   既然使用axios直接进行跨域访问不可行，我们就需要配置代理了。代理可以解决的原因：因为客户端请求服务端的数据是存在跨域问题的，而服务器和服务器之间可以相互请求数据，是没有跨域的概念（如果服务器没有设置禁止跨域的权限问题），也就是说，我们可以配置一个代理的服务器可以请求另一个服务器中的数据，然后把请求出来的数据返回到我们的代理服务器中，代理服务器再返回数据给我们的客户端，这样我们就可以实现跨域访问数据。

   准备工作：安装所需中间件和插件等，比如axios,http-proxy-middleware等。

   具体案例：这里以访问豆瓣Top250为例，直接访问如下：

   ```
   axios.get("http://api.douban.com/v2/movie/top250")
   .then(res=>{
   	console.log(res)
   })
   .catch(err=>{
   	console.log(err)
   })
   ```

   当执行npm run dev时，控制台报错如下：

   ![img](https://img-blog.csdnimg.cn/2019021914123491.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doX3hteQ==,size_16,color_FFFFFF,t_70)

   事实证明直接请求确实出现跨域问题了，下面具体演示解决跨域问题的步骤：

   上面所说的必备条件都已安装完成的情况下，执行以下步骤即可解决问题：

   1.配置BaseUrl

   在main.js中，配置数据所在服务器的前缀（即固定部分），代码如下：

   ```
   // 项目入口，配置全局vue
   import Vue from 'vue'
   import VueRouter from './router/routes.js'
   import Store from './store/index.js'
   import './assets/less/index.less'
   import App from './App.vue'
   import ElementUI from 'element-ui'
   import 'element-ui/lib/theme-default/index.css'
   import axios from 'axios'
   Vue.prototype.$axios = axios
   axios.defaults.baseURL = '/api'  //关键代码
   Vue.config.productionTip = false
   Vue.use(ElementUI);
   new Vue({
   	router:VueRouter,
   	store:Store,
   	template:'<App/>',
   	components: {App}
   }).$mount('#app')
   // 默认进入商品模块
   // VueRouter.push({ path: '/home' })
   ```

   关键代码：axios.defaults.baseURL = '/api'，作用是我们每次发送的请求都会带一个/api的前缀。

   2.配置代理

   在config文件夹下的index.js文件中的proxyTable字段中，作如下处理：

   ```
     dev: {
       env: require('./dev.env'),
       port: 8090,
       autoOpenBrowser: true,
       assetsSubDirectory: 'static',
       assetsPublicPath: '/',
       proxyTable: {
         '/api': {
           target:'http://api.douban.com/v2', // 你请求的第三方接口
           changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
           pathRewrite:{  // 路径重写，
             '^/api': ''  // 替换target中的请求地址，也就是说以后你在请求http://api.douban.com/v2/XXXXX这个地址的时候直接写成/api即可。
           }
         }
       },
       // CSS Sourcemaps off by default because relative paths are "buggy"
       // with this option, according to the CSS-Loader README
       // (https://github.com/webpack/css-loader#sourcemaps)
       // In our experience, they generally work as expected,
       // just be aware of this issue when enabling this option.
       cssSourceMap: false
     }
   ```

   3.在具体使用axios的地方，修改url如下即可：

   ```
   axios.get("/movie/top250").then((res) => {
      res = res.data
      if (res.errno === ERR_OK) {
        this.themeList=res.data;
      }
     ).catch((error) => {
      console.warn(error)
   })
   ```

   4.重新启动项目之后，已经解决了跨域问题，结果如下：

   ![img](https://img-blog.csdnimg.cn/20190219142524890.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doX3hteQ==,size_16,color_FFFFFF,t_70)

   原理：

   因为我们给url加上了前缀/api，我们访问/movie/top250就当于访问了：localhost:8080/api/movie/top250（其中localhost:8080是默认的IP和端口）。

   在index.js中的proxyTable中拦截了/api,并把/api及其前面的所有替换成了target中的内容，因此实际访问Url是http://api.douban.com/v2/movie/top250。

   至此，纯前端配置代理解决axios跨域得到解决。

- 13.v-model的使用

   ### v-model 用在 input 元素上时

   `v-model`虽然很像使用了双向数据绑定的 Angular 的 `ng-model`，**但是 Vue 是单项数据流**，`v-model` 只是语法糖而已：↓

   ```html
   <input v-model="sth" />
   <input :value="sth" @input="sth = $event.target.value" />
   ```

   第一行的代码其实只是第二行的语法糖，**两行代码是等价的**。

   要理解这行代码，首先你要知道 `input` 元素本身有个 [oninput](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.runoob.com%2Fjsref%2Fevent-oninput.html) 事件，这是 HTML5 新增加的，类似 `onchange` ，每当输入框内容发生变化，就会触发 `oninput` ，把最新的`value`赋值给 `sth`变量。
    如果你不知道  [$event](https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fevents.html) 是从哪来的，那你需要点击它再复习一下文档。

   我们仔细观察语法糖和原始语法那两行代码，可以得出一个**结论**：

   **在给 <input /> 元素添加 v-model 属性时，默认会把 `value` 作为元素的属性，把 `input` 事件作为实时传递 value 的触发事件**
    （理解上面那句话非常重要，如果没有理解，务必再把上面的内容多看两遍，多想想，直到理解为止）

   ------

   ### 当 v-model 用在组件上时

   `v-model` 不仅仅能在 `input`HTML 原生标签上用，在 vue 组件上也能使用；下面是一个和 Vue 官网教程类似的例子：

   ![img](https:////upload-images.jianshu.io/upload_images/1430985-7b1aa19fecc5efb1.gif?imageMogr2/auto-orient/strip|imageView2/2/w/320/format/webp)

   实例演示.gif

   父组件 `price` 的初始值是 100，子组件是一个输入框；输入框的值改变时，能实时更新父组件的 `price`

   ```html
   // 父组件
   <template>
   <div id="demo">
     <currency-input v-model="price"></currentcy-input>
     <span>{{price}}</span>
   </div>
   </template>
   
   <script>
   export default {
     data() {
       return {
         price: 100,
       }
     }
   }
   </script>
   ```

   ```html
   // 子组件 currency-input
   <template>
     <input
       :value="value"
       @input="$emit('input', $event.target.value)"
     />
      <!--为什么这里把 'input' 作为触发事件的事件名？`input` 在哪定义的？-->
   </template>
   
   <script>
   export default {
     props: {
       value: String,  // 为什么这里要定义 value 属性，父组件貌似没有给子组件传递 value 啊？
     }
   }
   </script>
   ```

   注释里列了两个问题，**如果你都知道答案，那么恭喜你真正掌握了 `v-model`**!
    如果你没明白，那么可以继续往下看

   ------

   我们对比下下面两行代码

   ```html
   <currency-input v-model="price"></currentcy-input>
   <currency-input :value="price" @input="price = $event.target.value"></currency-input>
   ```

   这两行代码实际上没有任何区别，只不过第一行是第二行的语法糖而已！
    现在你知道 `value` 和 `input` 从哪来的了吧。与上面总结的类似：

   **给组件添加 `v-model` 属性时，默认会把`value` 作为组件的属性，把 `input`作为给组件绑定事件时的事件名**

   ------

   ### v-model 的缺点和解决办法

   v-model 应用到组件上，会有一些体验不好的场景。因为它默认会把 `value` 作为组件的属性，把 `input`作为给组件绑定事件时的事件名。

   ```html
   // 父组件
   <my-button v-model="number"></my-button>
   <script>
   data() {
     return {
       number: 1,
     }
   }
   </script>
   
   // 子组件
   <template>
     <button @click="add">点击按钮自增 1</button>
   </template>
   
   <script>
   export default {
     props: {
       value: Number, //  属性名必须是 value
     },
   
     methods: {
       add() {
         this.$emit('input', this.value + 1) // 事件名必须是 input
       },
     }
   }
   </script>
   ```

   有时间我们不想用 `value` 当做默认的属性名，也不想把 `input` 当做事件名。能不能自定义呢？

   ------

   在 Vue 2.2 及以上版本，你可以在定义组件时通过 model 选项的方式来定制 prop/event：

   ```html
   // 父组件
   <my-button v-model="number"></my-button>
   <script>
   data() {
     return {
       number: 1,
     }
   }
   </script>
   
   // 子组件
   <template>
     <button @click="add">点击按钮自增 1</button>
   </template>
   
   <script>
   export default {
     model: {
       prop: 'num', // 自定义属性名
       event: 'addNum' // 自定义事件名
     },
     props: {
       num: Number,
     },
   
     methods: {
       add() {
         this.$emit('addNum', this.num + 1)
       },
     }
   }
   </script>
   ```

- 14.scss的安装以及使用

   ##### 一、安装

   ```html
   npm install node-sass --save-dev //安装node-sass 
   
   
   
   npm install sass-loader --save-dev //安装sass-loader 
   
   
   
   npm install style-loader --save-dev //安装style-loader 有些人安装的是 vue-style-loader 其实是一样的！
   ```

   ##### 二、配置文件

   ```html
   在webpack.base.conf.js 文件下的配置 rules
   rules:[
   
   
   
   ...
   
   
   
   { //从这一段上面是默认的！不用改！下面是没有的需要你手动添加，相当于是编译识别scss!
   
   
   
       test: /\.scss?$/,
   
   
   
       loaders: ["style", "css", "sass"]
   
   
   
   }
   
   
   
   ]
   ```

   ![img](https://img-blog.csdnimg.cn/20190522100027976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NjA1NjQy,size_16,color_FFFFFF,t_70)在webpack.base.conf.js 文件下的配置 rules

   ##### 三、在vue模板组件中引用lange="scss"

   ```css
   <style lang="scss" scoped>
   
   ...
   
   </style>
   ```

   ![img](https://img-blog.csdnimg.cn/20190522100520726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NjA1NjQy,size_16,color_FFFFFF,t_70)style中引入

- 15.请说出vue.cli项目中src目录每个文件夹和文件的用法？

   assets文件夹是放静态资源；

   components是放组件；

   router是定义路由相关的配置;

   view视图；

   app.vue是一个应用主组件；

   main.js是入口文件

- 16.分别简述computed和watch的使用场景

   1、区别

   watch中的函数是不需要调用的

   computed内部的函数调用的时候不需要加()

    

   watch 属性监听 监听属性的变化

   computed:计算属性通过属性计算而得来的属性

    

   watch需要在数据变化时执行异步或开销较大的操作时使用

   对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时，也要发生变化，这种情况下，我们最好使用计算属性computed。 

    

   computed 属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；

   computed中的函数必须用return返回最终的结果

   当computed中的函数所依赖的属性如果没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取

   watch 一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；

   2、使用场景

   computed 　　　

   　　　　当一个属性受多个属性影响的时候就需要用到computed

   　　　　最典型的例子： 购物车商品结算的时候

   *watch*

   　　　　当一条数据影响多条数据的时候就需要用watch

   　　　　搜索数据

- 17.v-on可以监听多个方法吗

   可以

- 18.$nextTick的使用

   `$nextTick` 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM

   ```
   <div class="app">
     <div ref="msgDiv">{{msg}}</div>
     <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
     <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
     <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
     <button @click="changeMsg">
       Change the Message
     </button>
   </div>
    
    
   new Vue({
     el: '.app',
     data: {
       msg: 'Hello Vue.',
       msg1: '',
       msg2: '',
       msg3: ''
     },
     methods: {
       changeMsg() {
         this.msg = "Hello world."
         this.msg1 = this.$refs.msgDiv.innerHTML
         this.$nextTick(() => {
           this.msg2 = this.$refs.msgDiv.innerHTML
         })
         this.msg3 = this.$refs.msgDiv.innerHTML
       }
     }
   })
   ```

   点击前：

   ![img](https://img-blog.csdnimg.cn/20190716160829257.png)

   点击后：

   ![img](https://img-blog.csdnimg.cn/20190716160848674.png)

   从上图可知，vue中的msg1和msg3显示的数据还是赋值之前的，msg2显示的数据则是赋值之后的。其根本原因是vue中的dom渲染是异步的。

- 19.vue组件中data为什么必须是一个函数

   如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

- 20.vue事件对象的使用

   ##### 一、概述

   事件被触发时，会生成一个事件对象event，该对象中包含所有与事件相关的信息。Vue中使用v-on指令绑定事件，该指令可以接收两种类型的参数，其一函数形式，其二函数执行的形式，即函数名后加小括号。

   ```html
   <span v-on:click="click()"></span>
   <span v-on:click="click"></span>
   ```

   ##### 二、详解

   Vue中事件对象的获取方式与v-on指令的参数值有关。

   > **函数形式**

   若参数采用函数形式，则事件侦听器处理函数的第一个参数默认接收事件对象event，event对象将被自动当做实参传入。注意，形参的名称可以自定义。

   ```html
   <template>
     <div>
       <button v-on:click="click">button</button>
     </div>
   </template>
   <script>
   export default {
     methods: {
       click(event) {
         console.log(event);    // MouseEvent{......}
       }
     }
   }
   </script>
   ```

   > **函数执行的形式**

   若参数采用函数执行的形式，则需要使用$event变量向事件侦听器处理函数中显示传入event对象。注意，实参名称即$event变量名不能自定义。

   ```html
   <template>
     <div>
       <button v-on:click="click($event)">button</button>
     </div>
   </template>
   <script>
   export default {
     methods: {
       click(event) {
         console.log(event);    // MouseEvent{......}
       }
     }
   }
   </script>
   ```

   ##### 三、拓展

   > **拓展1：$event.target.value**

   可以通过$event.target获取事件所在的DOM对象，再通过value进一步获取具体的值。如下代码所示，当触发input事件时，$event是当前的事件对象，$event.target.value指向当前输入框的值。

   ```html
   <input :value='val' @input="$emit('update', $event.target.value)"/>
   ```

   > **拓展2：window.event**

   ```html
   <template>
     <div>
       <button v-on:click="click()">button</button>
     </div>
   </template>
   <script>
   export default {
     methods: {
       click() {
         console.log(event);
       }
     }
   }
   </script>
   ```

   如上代码所示，侦听器的处理函数即没有传入实参，也没有设置形参，但在chrome浏览器中运行却可以打印出事件对象。那么这个event对象来自哪里呢？其实它来自于全局作用域，即window.event。

   MDN上有明确提出，ie浏览器和chrome浏览器在window对象上都有一个event属性。不推荐使用window.event，兼容性不好，如Firefox浏览器中的window对象就没有event属性。

- 21 组件间的通信

   1.props/$emit

   2.事件总线

   3.vuex

- 22.渐进式框架的理解

   所谓渐进式官网上可以理解为 易用、灵活、高效，但是绝大部分框架多是以这几点著称，所有概括还是有些笼统，所以这里用大白话说下对渐进式的理解，所谓渐进式就是没有太多限制的一个js框架，举个例子，比如angular，它是一个比较重的框架，但它就不属于一个渐进式的框架，因为它有很多的限制，如果你想用它的框架，就必须要遵守它的许多规则，它不太容易于第三方的的一些其他优秀的库融合，但是vue就不一样了，它没有这么多的限制，它可以很好地跟一些其他的第三方库集成起来，这就是我所理解的渐进式框架

- 23.Vue中双向数据绑定是如何实现的

   **Vue的双向数据绑定是通过数据劫持结合发布者订阅者模式来实现的 要实现这种双向数据绑定，必要的条件有：**

   1. 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者

   2. 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数

   3. 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

   4. MVVM入口函数，整合以上三者

      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport"
                content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
          <meta http-equiv="X-UA-Compatible" content="ie=edge">
          <title>$Title$</title>
      </head>
      <body>
      ES5：Object.defineProperty
      <div style="width: 100%;height: 1px;background-color:red;margin-top: 10px"></div>
      <br/>
      输入框:<span id="sp"></span>
      <br/>
      <input type="text" id="ipt" autocomplete="off">
      <script>
          let obj = {
              name: ''
          }
          let newObj = {
              ...obj
          }
          Object.defineProperty(obj, 'name', {
              get() {
                  return newObj.name
              },
              set(v) {
                  newObj.name = v
                  observe()
              }
          })
      
          function observe() {
              sp.innerHTML = newObj.name
          }
      
          ipt.oninput = function () {
              obj.name = this.value
          }
      </script>
      <br/><br/>
      ES6：Proxy
      <br/>
      <div style="width: 100%;height: 1px;background-color:red;margin-top: 10px"></div>
      <br/>
      输入框:<span id="sp1"></span>
      <br/>
      <input type="text" id="ipt1">
      <script>
          let obj2 = {
              name: ''
          }
          obj2 = new Proxy(obj2, {
              get(target, p) {
                  return target[p]
              },
              set(target, p, value) {
                  target[p] = value
                  observe2()
              }
          })
      
          function observe2() {
              sp1.innerHTML = obj2.name
          }
      
          ipt1.oninput = function () {
              obj2.name = this.value
          }
      </script>
      </body>
      </html>
      ```

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/202006072059266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211Z2UxMTYxMTA1NDAz,size_16,color_FFFFFF,t_70#pic_center)

- 24.单页面应用和多页面应用区别及优缺点

   单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。

   多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新

   单页面的优点：

   1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小

   2，前后端分离

   3，页面效果会比较炫酷（比如切换页面内容时的专场动画）

   单页面缺点：

   1，不利于seo

   2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）

   3，初次加载时耗时多

   4，页面复杂度提高很多

   ![img](https://images2018.cnblogs.com/blog/1013869/201804/1013869-20180413214226425-113139192.png)

- 25.vue中过滤器有什么作用及详解

   #### 一、过滤器详解

   Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化，比如字母全部大写、货币千位使用逗号分隔等。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号“（|）”指示。过滤器可以用在两个地方：双花括号插值和 v-bind表达式 。比如：

   ```html
   <!-- 在双花括号中 -->
   {{ message | capitalize }}
   
   <!-- 在 v-bind 中 -->
   <div v-bind:id="rawId | formatId"></div>
   12345
   ```

   可以在一个组件的选项里定义本地的过滤器：

   ```javascript
   filters:{
       capitalize:function (val) {
           return val.toUpperCase();
       }
   1234
   ```

   或者在创建 Vue 实例之前全局定义过滤器：

   ```javascript
   Vue.filter('capitalize',function(val) {
           return val.toUpperCase();
       })
   new Vue({
   //...
   })
   123456
   ```

   当全局过滤器和局部过滤器重名时，会采用局部过滤器。

   过滤器是 JavaScript 函数，因此可以接收多个参数。过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。比如

   ```html
   <div id="app">
       {{10|toRMB(' 元')}}
   </div>
   123
   <script>
       var app = new Vue({
           el:'#app',
           data:{},
           method:{},
           filters:{
               toRMB:function (val,type) {
                   return '￥'+val+type;
               }
           }
       })
   </script>
   123456789101112
   ```

   以上这个例子，toRMB过滤器函数将会收到10作为第一个参数。

   过滤器可以串联，也就是说过滤器可以有好几个函数：

   ```html
   <div id = "app">
       {{setence|toCapitalize|addPreSetence}}
   </div>
   123
   <script>
       var app = new Vue({
           el:"#app",
           data:{
               setence:'Hello world'
           },filters:{
               toCapitalize:function (val) {
                   return val.toUpperCase();
               },
               addPreSetence:function (val) {
                   return 'The setence is:'+val;
               }
           }
   
       })
   </script>
   12345678910111213141516
   ```

   在这个例子中，toCapitalize被定义为接受单个参数的过滤器函数，表达式setence的值作为参数传入到函数里。然后继续调用同样被定义为接受单参数的过滤器函数addPreSetence，将toCapitalize的结果传递到addPreSetence中。

   #### 二、应用举例

   Q：建立一个时间过滤器，把一个时间变量变成一个合符要求的时间格式 。

   ```html
   <div id="app">
       {{data|formatDate}}
   </div>
   123
   <script src="../plugin/vue.js"></script>
   <script>
       //在月份、日期、小时等小于10是前面补0
       var padDate = function (value) {
           return value<10 ? '0'+value : value;
       };
       var app = new Vue({
           el:'#app',
           data:{
               data:new Date()
           },
           filters:{
               formateDate:function (value) {//这里的value就是需要过滤的数据
                   var date = new Date(value);
                   var year = date.getFullYear();
                   var month = padDate(date.getMonth()+1);
                   var day = padDate(date.getDate());
                   var hours = padDate(date.getHours());
                   var minutes = padDate(date.getMinutes());
                   var seconds = padDate(date.getSeconds());
                   //将整理好的数据返回出去
                   return year+'-'+month+'-'+day+' ' +hours+':'+minutes+':'+seconds;
               }
           },
           mounted:function(){
               var _this = this;//声明一个变量指向Vue实例this，保证作用域一致
               this.timer = setInterval(function () {
                   _this.date = new Date();//修改数据date
               },1000);
           },
           beforeDestroy:function () {
               if(this.timer){
                   clearInterval(this.timer);//在Vue实例销毁前，消除我们的定时器
               }
           }
       })
   </script>
   ```

- 26.v-if和v-for的优先级

   v-for比 v-if 具有更高的优先级，两者最好不要用到同一元素上

- 27.assets和static的区别

   #### 1、**相同点：** 文件夹中的资源在html中使用都是可以的。

   #### 2、不同点：

   ```undefined
   使用assets下面的资源，在js中使用的话，路径要经过webpack中的file-loader编译，路径不能直接写
   ```

   ##### 2.1 **static**  :

   该目录下的文件是不会被wabpack处理的，它们会被直接复制到最终的打包目录下面（默认是 `dist/static` ），且必须使用绝对路径来引用这些文件。

   这是通过在 `config.js` 文件中的 `build.assetsPublicPath` 和 `build.assetsSubDirectory` 链接来确定的

   **注意**：任何放在 static 中的文件需要以绝对路径的形式引用：`/static/[filename]`

   ##### 2.2 **assets**:

   assets 中的文件会经过 webpack 打包，重新编译

   ```jsx
   注意：  1、static中的文件，是不会经过编译的，打包后会生成dist文件夹，static中的文件只是复制一面。
           因此，static中建议放一些外部第三方，自己的文件放在assets，别人的放在static中
   
   2、若把图片放在assets和static中，html页面中都可以使用；
      但是在动态绑定中，assets路径的图片会加载失败，
     因为webpack使用的是 ` commenJS ` 规范，必须使用require才可以
   ```

   ```kotlin
   //   HTML  结构
   
   <div class="myDemo">
       //   直接显示文件内容
       <h5>直接路径</h5>
       
       <img src="../assets/logo.png" title="assets中的图片">
       <img src="/static/logo.png" title="static中的图片">
       
       //   动态显示文件内容
       <h5>动态路径</h5>
       
       <img :src="asetUrl" title="assets中的图片">
       <img :src="sticUrl" title="static中的图片">
       
   </div>
   
   //   JS  
   
   export default {
       name: 'myDemo',
       data (){
         return {
           asetUrl: require('../assets/logo.png'),
           sticUrl: '/static/logo.png'
       }
   }
   ```

- 28.列举常用的指令

   1、v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。
   2、v-show：根据表达式之真假值，切换元素的 display CSS 属性。
   3、v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。
   4、v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。
   5、v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。
   6、v-model：实现表单输入和应用状态之间的双向绑定
   7、v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。
   8、v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

- 29.vue常用的修饰符

   1、.lazy：

   输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据：

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095359145-2129658851.png)

   2、.trim：

   输入框过滤首尾的空格：

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095421707-831592670.png)

   3、.number：

   先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字：   

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095441517-895479507.png)

   **二、事件修饰符**

   4、.stop：

   阻止事件冒泡，相当于调用了event.stopPropagation()方法：

    ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095722262-891576888.png)

   5、.prevent：

   阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件：

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095520346-1148774494.png)

   6、.self：

   只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡：

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095746426-1272980881.png)

   7、.once：

   事件只能用一次，无论点击几次，执行一次之后都不会再执行

   ![img](https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095802227-1462269056.png)

   8、.capture：

   事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡

   9、.sync

   对prop进行双向绑定

   10、.keyCode：

   监听按键的指令，具体可以查看vue的键码对应表

- 30.数组更新检测

   Vue 包含两种观察数组的方法分别如下

   　1.变异方法

   　　顾名思义，变异方法会改变被这些方法调用的原始数组，它们也将会触发视图更新，这些方法如下

   　　　　`push()`

   ```
   　　　　``pop()
   　　　　``shift()
   　　　　``unshift()
   　　　　``splice()
   　　　　``sort()
   　　　　``reverse()
   ```

   　　　使用举例：`example1.items.push({ message: 'Baz' })` 

   　2.非变异方法

   　　非变异方法与变异方法的区别就是，非变异方法不会改变原始数组，总是返回一个新数组，

   　　当使用非变异方法时，可以用新数组替换旧数组，非变异方法大致有：`filter()`, `concat()` 和 `slice()`

   　　使用举例：

   ```
   example1.items = example1.items.filter(function (item) {
     return item.message.match(/Foo/)
   })
   ```

    

   **由于 JavaScript 的限制，Vue 不能检测以下变动的数组：**

   　1.当你利用索引直接设置一个项时，例如：`vm.items[indexOfItem] = newValue`

   　2.当你修改数组的长度时，例如：`vm.items.length = newLength`

   vue针对这两个问题给出了相应的解决办法,使用这两种方法，也会触发状态更新

   　1.使用vue全局方法Vue.set() 或者使用vm.$set() 实例方法

   　2.使用 splice，caoncat等修改数组

    

   Vue.set用法如下（vm.$set方法是Vue.set的别名，与其用法一致）

   　　![img](https://img2018.cnblogs.com/blog/1459377/201812/1459377-20181208115857633-1521960070.png)

   总的来说：vue能不能检测到数组的变化并更新，取决于原生js的数组方法，

   　　　　　如果原生js方法（vue变异方法）能够修改原数组，那么vue就可以检测到变化并更新（例如push等方法）

   　　　　　如果原生js方法（vue非变异方法）不能够修改原数组，而是返回一个新数组，那么vue也可以检测到变化并更新，

   　　　　　　　　前提是使用这些方法时要把新数组返回出来去替换掉旧数组

   　　　　　至于原生js的数组的两个坑，我们一定到注意，直接利用vue提供的方法来解决

- 31.Vue.set视图更新

   这里我定义了一个列表数据，我将通过按钮来控制列表数据。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421095137425.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQxODE5,size_16,color_FFFFFF,t_70)

   > 比如我们修改一个数组其中的一个值，或者添加一条数据时，不管用。

   ```javascript
   <template>
     <div id="app" style="padding: 100px">
       <el-link type="primary" v-for="item in items" :key="item.id" style="margin-right: 10px">{{item.message}}</el-link>
       <el-button @click='btn2Click()'>动态赋值</el-button>
     </div>
   </template>
   <script>
     import Vue from 'vue'
       export default {
         name: "test",
         data() {
           return{
             items:[
               {message:"Test one",id:"1"},
               {message:"Test two",id:"2"},
               {message:"Test three",id:"3"}
             ]
           }
         },
         methods:{
           btn2Click(){
             this.items[0] = {message:"Test four",id:"10"}
             console.log(this.items)
           },
         },
       }
   </script>
   
   12345678910111213141516171819202122232425262728
   ```

   当我点击按钮通过JS赋值的方法,将Tset one改为 Test four时，发现控制台已经改变了，但是视图并没有更新
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421095419843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQxODE5,size_16,color_FFFFFF,t_70)
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421095428891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQxODE5,size_16,color_FFFFFF,t_70)
   因此修改失败

   Vue.set() 方法
   调用方法：Vue.set( target, key, value )
   target：要更改的数据源(可以是对象或者数组)
   key：要更改的具体数据
   value ：重新赋的值

   ```javascript
   <template>
     <div id="app" style="padding: 100px">
       <el-link type="primary" v-for="item in items" :key="item.id" style="margin-right: 10px">{{item.message}}</el-link>
       <el-button @click='btn2Click()'>动态赋值</el-button>
     </div>
   </template>
   <script>
     import Vue from 'vue'
       export default {
         name: "test",
         data() {
           return{
             items:[
               {message:"Test one",id:"1"},
               {message:"Test two",id:"2"},
               {message:"Test three",id:"3"}
             ]
           }
         },
         methods:{
           btn2Click(){
             Vue.set(this.items,0,{message:"Test four",id:"10"})
             console.log(this.items)
           },
         },
       }
   </script>
   
   12345678910111213141516171819202122232425262728
   ```

   还是点击按钮如下图
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421100015134.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQxODE5,size_16,color_FFFFFF,t_70)
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421100024330.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDQxODE5,size_16,color_FFFFFF,t_70)
   这次控制台变化的同时，视图页面也跟着变化

   > 总结：
   > 在vue文档中写着如果在实例创建之后添加新的属性到实例上，它不会触发视图更新
   > 数据发生变化视图不更新 那就要Vue.set方法来设置

- 32.自定义指令详解

- 33.vue的两个核心点

   vue.js的两大核心：1. 数据驱动 ------------- 2.组件系统

   ### 1. 数据驱动，也就是数据的双向绑定

   Vue 响应式核心就是，getter 的时候会收集依赖，setter 的时候会触发依赖更新

   vue将遍历data中对象的所有property，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。

   这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。

   每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。

   getter 的时候我们会收集依赖，依赖收集就是订阅数据变化watcher的收集，依赖收集的目的是当响应式数据发生变化时，能够通知相应的订阅者去处理相关的逻辑。

   setter 的时候会触发依赖更新，之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

   ### 2. 组件系统

   组件的核心选项

   1 模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。

   2 初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。

   3 接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。

   4 方法（methods）：对数据的改动操作一般都在组件的方法内进行。

   5 生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。

   6 私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用

- 34.vue和jQuery的区别

   从jquery到vue或者说是到mvvm的转变是一个思想的转变，是将原有的直接操作dom的思想转变到操作数据上去

   ##### vue和jquey对比 

   - jQuery是使用**选择器（$）选取DOM对象**，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以**更方便的选取和操作DOM对象**，而数据和界面是在一起的。比如需要获取label标签的内容：`$("lable").val();`,它还是依赖DOM元素的值。 
   - Vue则是通过Vue对象**将数据和View完全分离**开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们**通过Vue对象这个vm实现相互的绑定**。这就是传说中的MVVM。

   　　vue适用的场景：复杂数据操作的后台页面，表单填写页面

   　　jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面

   　　然而二者也是可以结合起来一起使用的，vue侧重数据绑定，jquery侧重样式操作，动画效果等，则会更加高效率的完成业务需求

- 35 引进组件的步骤

   1.采用ES6的import … from …语法
   或
   CommonJS的require()方法引入组件

   2.对组件进行注册,代码如下
   注册

   ```
   Vue.component('my-component',
   {  template: '<div>A custom component!</div>'})
   12
   ```

   3.使用组件

   ```
   <my-component></my-component>
   ```

- 36.Vue-cli打包命令是什么？打包后悔导致路径问题，应该在哪里修改

   npm run build

- 37.三大框架的对比

- 38.跨组件双向数据绑定

- 39.delete和Vue.delete删除数组的区别

   delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变，数组长度不变。

   Vue.delete 直接删除了数组 改变了数组的键值，数组长度改变。

- 40.SPA首屏加载慢如何解决

- 41.Vue-router跳转和location.href有什么区别

- 42.vue slot

- 43.你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？

- 44.vue遇到的坑，如何解决的？

- 45.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？

- 46.Vue2中注册在router-link上事件无效解决方法

- 47.RouterLink在IE和Firefox中不起作用（路由不跳转）的问题

- 48.axios的特点有哪些

- 49.请说下封装 vue 组件的过程？

- 50.vue 各种组件通信方法（父子 子父 兄弟 爷孙 毫无关系的组件）

- 51.params和query的区别

- 52.vue mock数据

- 53 vue封装通用组件

- 54.vue初始化页面闪动问题

- 55.vue禁止弹窗后的屏幕滚动

- 56.vue更新数组时触发视图更新的方法

- 57.vue常用的UI组件库

- 58.vue如何引进本地背景图片

- 59.vue如何引进sass

- 60.vue修改打包后静态资源路径的修改

**vuex常见面试题**

- 1.vuex是什么？怎么使用？哪种功能场景使用它？
- 2.vuex有哪几种属性
- 3.不使用Vuex会带来什么问题
- 4.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？
- 5.vuex一个例子方法
- 6.Vuex中如何异步修改状态
- 7.Vuex中actions和mutations的区别

**vue项目实战**

- 1.顶部悬停效果
- 2.电话本列表效果（ 右边字母分类 上下滑动 旁边字母显示高亮）
- 3.vue做代理
- 4.Vue路由切换时的左滑和右滑效果示例

## **ES6面试题**


**ES6新增方法面试题**

- 1.let const var比较
- 2.反引号（`）标识
- 3.函数默认参数
- 4.箭头函数
- 5.属性简写
- 6.方法简写
- 7.Object.keys()方法，获取对象的所有属性名或方法名
- 8.Object.assign ()原对象的属性和方法都合并到了目标对象
- 9.for...of 循环
- 10.import和export
- 11.Promise对象
- 12.解构赋值
- 13.set数据结构（可用于快速去重）
- 14.Spread Operator 展开运算符(...)
- 15.字符串新增方法



**ES6数组面试题**

- 1.forEach()
- 2.map()
- 3.filter()
- 4.reduce()
- 5.some()
- 6.every()
- 7.all()方法

**ES6编程题**

- 1.使用解构，实现两个变量的值的交换
- 2.利用数组推导，计算出数组 [1,2,3,4] 每一个元素的平方并组成新的数组。
- 3.使用ES6改下面的模板
- 4.把以下代码使用两种方法，来依次输出0到9？

## **react面试题**


**react生命周期面试题**

- 1.react 生命周期函数
- 2.react生命周期中，最适合与服务端进行数据交互的是哪个函数
- 3.运行阶段生命周期调用顺序
- 4.shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）
- 5.指出(组件)生命周期方法的不同

**react 基础面试题**

- 1.React 中 keys 的作用是什么？
- 2.React 中 refs 的作用是什么？
- 3.React 中有三种构建组件的方式
- 4.调用 setState 之后发生了什么？
- 5.react diff 原理（常考，大厂必考）
- 6.为什么建议传递给 setState 的参数是一个 callback 而不是一个对象
- 7.除了在构造函数中绑定 this，还有其它方式吗
- 8.setState第二个参数的作用
- 9.(在构造函数中)调用 super(props) 的目的是什么
- 10.简述 flux 思想
- 11.在 React 当中 Element 和 Component 有何区别？
- 12.描述事件在 React 中的处理方式。
- 13.createElement 和 cloneElement 有什么区别？
- 14.如何告诉 React 它应该编译生产环境版本？
- 15.Controlled Component 与 Uncontrolled Component 之间的区别是什么？

**react组件面试题**

- 1.展示组件(Presentational component)和容器组件(Container component)之间有何不同
- 2.类组件(Class component)和函数式组件(Functional component)之间有何不同
- 3.(组件的)状态(state)和属性(props)之间有何不同
- 4.何为受控组件(controlled component)
- 5.何为高阶组件(higher order component)
- 6.应该在 React 组件的何处发起 Ajax 请求
- 7.react中组件传值
- 8.什么时候在功能组件( Class Component )上使用类组件( Functional Component )？
- 9.受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？
- 10.react 组件的划分业务组件技术组件？

**redux面试题**

- 1.redux中间件
- 2.redux有什么缺点
- 3.了解 redux 么，说一下 redux 把



**react性能比较面试题**

- 1.vue和react的区别
- 2.react性能优化的方案
- 3.React 项目用过什么脚手架
- 4.介绍一下webpack webpack
- 5.如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？
- 6.为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？



**js面试题**

- 1.简述同步和异步的区别
- 2.怎么添加、移除、复制、创建、和查找节点
- 3.实现一个函数clone 可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制
- 4.如何消除一个数组里面重复的元素
- 5.写一个返回闭包的函数
- 6.使用递归完成1到100的累加
- 7.Javascript有哪几种数据类型
- 8.如何判断数据类型
- 9.console.log(1+'2')和console.log(1-'2')的打印结果
- 10.Js的事件委托是什么，原理是什么
- 11.如何改变函数内部的this指针的指向
- 12.列举几种解决跨域问题的方式，且说明原理
- 13.谈谈垃圾回收机制的方式及内存管理
- 14.写一个function ，清除字符串前后的空格
- 15.js实现继承的方法有哪些
- 16.判断一个变量是否是数组，有哪些办法
- 17.let ，const ，var 有什么区别
- 18.箭头函数与普通函数有什么区别
- 19.随机取1-10之间的整数
- 20.new操作符具体干了什么
- 21.Ajax原理
- 22.模块化开发怎么做
- 23.异步加载Js的方式有哪些
- 24.xml和 json的区别
- 25.webpack如何实现打包的
- 26.常见web安全及防护原理
- 27.用过哪些设计模式
- 28.为什么要同源限制
- 29.offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别
- 30.javascript有哪些方法定义对象
- 31.说说你对promise的了解
- 32.谈谈你对AMD、CMD的理解
- 33.web开发中会话跟踪的方法有哪些
- 34.介绍js有哪些内置对象？
- 35.说几条写JavaScript的基本规范？
- 36.javascript创建对象的几种方式？
- 37.eval是做什么的？
- 38.null，undefined 的区别？
- 39.[“1”, “2”, “3”].map(parseInt) 答案是多少？
- 40.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？
- 41.js延迟加载的方式有哪些？
- 42.defer和async
- 43.说说严格模式的限制
- 44.attribute和property的区别是什么？
- 45.ECMAScript6 怎么写class么，为什么会出现class这种东西?
- 46.常见兼容性问题
- 47.函数防抖节流的原理
- 48.原始类型有哪几种？null是对象吗？
- 49.为什么console.log(0.2+0.1==0.3) //false
- 50.说一下JS中类型转换的规则？
- 51.深拷贝和浅拷贝的区别？如何实现
- 52.如何判断this？箭头函数的this是什么
- 53.== 和 ===的区别
- 54.什么是闭包
- 55.JavaScript原型，原型链 ? 有什么特点？
- 56.typeof()和instanceof()的用法区别
- 57.什么是变量提升
- 58.all、apply以及bind函数内部实现是怎么样的
- 59.为什么会出现setTimeout倒计时误差？如何减少
- 60.谈谈你对JS执行上下文栈和作用域链的理解
- 61.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？
- 62.prototype 和 proto 区别是什么？
- 63.使用ES5实现一个继承？
- 64.取数组的最大值（ES5、ES6）
- 65.ES6新的特性有哪些？
- 66.promise 有几种状态, Promise 有什么优缺点 ?
- 67.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ?
- 68.Promise和setTimeout的区别 ?
- 69.如何实现 Promise.all ?
- 70.如何实现 Promise.finally ?
- 71.如何判断img加载完成
- 72.如何阻止冒泡？
- 73.如何阻止默认事件？
- 74.ajax请求时，如何解释json数据
- 75.json和jsonp的区别?
- 76.如何用原生js给一个按钮绑定两个onclick事件？
- 77.拖拽会用到哪些事件
- 78.document.write和innerHTML的区别
- 79.jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？
- 80.浏览器是如何渲染页面的？
- 81.$(document).ready()方法和window.onload有什么区别？
- 82.jquery中.get()提交和post()提交有区别吗？
- 83.对前端路由的理解？前后端路由的区别？
- 84.手写一个类的继承
- 85.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思



**正则表达式常见面试题**

- 1.给一个连字符串例如：get-element-by-id转化成驼峰形式。
- 2.匹配二进制数字
- 3.非零的十进制数字 (有至少一位数字, 但是不能以0开头)
- 4.匹配一年中的12个月
- 5.匹配qq号最长为13为
- 6.匹配常见的固定电话号码
- 7.匹配ip地址
- 8.匹配用尖括号括起来的以a开头的字符串
- 9.分割数字每三个以一个逗号划分
- 10.判断字符串是否包含数字
- 11.判断电话号码
- 12.判断是否符合指定格式
- 13.判断是否符合USD格式
- 14.JS实现千位分隔符
- 15.获取 url 参数
- 16.验证邮箱
- 17.验证身份证号码
- 18.匹配汉字
- 19.去除首尾的'/'
- 20.判断日期格式是否符合 '2017-05-11'的形式，简单判断，只判断格式
- 21.判断日期格式是否符合 '2017-05-11'的形式，严格判断（比较复杂）
- 22.IPv4地址正则
- 23.十六进制颜色正则
- 24.车牌号正则
- 25.过滤HTML标签
- 26.密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
- 27.URL正则
- 28.匹配浮点数



**浏览器/html/css面试题**

1.什么是盒模型

2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

3.简述src和href的区别

4.什么是css Hack

5.什么叫优雅降级和渐进增强

6.px和em的区别

7.HTML5 为什么只写

8.Http的状态码有哪些

9.一次完整的HTTP事务是怎么一个过程

10.HTTPS是如何实现加密

11.浏览器是如何渲染页面的

12.浏览器的内核有哪些？分别有什么代表的浏览器

13.页面导入时，使用link和@import有什么区别

14.如何优化图像，图像格式的区别

15.列举你了解Html5. Css3 新特性

16.可以通过哪些方法优化css3 animation渲染

17.列举几个前端性能方面的优化

18.如何实现同一个浏览器多个标签页之间的通信

19.浏览器的存储技术有哪些

20.css定位方式

21.尽可能多的写出浏览器兼容性问题

22.垂直上下居中的方法

23.响应式布局原理

25.清除浮动的方法

26.http协议和tcp协议

27.刷新页面，js请求一般会有哪些地方有缓存处理

28.如何对网站的文件和资源进行优化

29.你对网页标准和W3C重要性的理解

30.Http和https的区别

31.data-属性的作用

32.如何让Chrome浏览器显示小于12px的文字

33.哪些操作会引起页面回流（Reflow）

34.CSS预处理器的比较less sass

35.如何实现页面每次打开时清除本页缓存

36.什么是Virtual DOM,为何要用Virtual DOM

37.伪元素和伪类的区别

38.http的几种请求方法和区别

39.前端需要注意哪些SEO

40.的title和alt有什么区别

41.从浏览器地址栏输入url到显示页面的步骤

42.如何进行网站性能优化

43.语义化的理解

44.HTML5的离线储存怎么使用，工作原理能不能解释一下？

45.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢

46.iframe有那些缺点？

47.WEB标准以及W3C标准是什么?

48.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

49.HTML全局属性(global attribute)有哪些

50.Canvas和SVG有什么区别？

51.如何在页面上实现一个圆形的可点击区域？

52.网页验证码是干嘛的，是为了解决什么安全问题

53.请描述一下 cookies，sessionStorage 和 localStorage 的区别？

54.CSS选择器有哪些？哪些属性可以继承？

55.CSS优先级算法如何计算？

56.CSS3有哪些新特性？

57.请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？

58.用纯CSS创建一个三角形的原理是什么？

59.常见的兼容性问题？

60.为什么要初始化CSS样式

61.absolute的containing block计算方式跟正常流有什么不同？

62.CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？

63.display:none与visibility：hidden的区别？

64.position跟display、overflow、float这些特性相互叠加后会怎么样？

65.对BFC规范(块级格式化上下文：block formatting context)的理解？

66.为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？

67.上下margin重合的问题

68.设置元素浮动后，该元素的display值是多少？

69.移动端的布局用过媒体查询吗？

70.CSS优化、提高性能的方法有哪些？

71.浏览器是怎样解析CSS选择器的？

72.在网页中的应该使用奇数还是偶数的字体？为什么呢？

73.margin和padding分别适合什么场景使用？

74.元素竖向的百分比设定是相对于容器的高度吗？

75.全屏滚动的原理是什么？用到了CSS的哪些属性？

76.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？

77.视差滚动效果？

78.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用

79.让页面里的字体变清晰，变细用CSS怎么做？

80.position:fixed;在android下无效怎么处理？

81.如果需要手动写动画，你认为最小时间间隔是多久，为什么？

[82.li与li之间有看不见的空白间隔是什么原因引起的](https://link.zhihu.com/?target=http%3A//82.xn--lili-jb5fd32bwa86hl07a2vimuze9ufxcqx2ggdah43vi90a275ejkqr67bha459a/)？有什么解决办法？

83.display:inline-block 什么时候会显示间隙？

84.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度

85.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？

86.style标签写在body后与body前有什么区别？

87.CSS属性overflow属性定义溢出元素内容区的内容会如何处理?

88.阐述一下CSS Sprites



## **微信小程序开发（持续更新）** 

**初识小程序**

- 1.注册小程序

- 2.微信开发者工具

- 3.小程序与普通网页开发的区别

- 4.小程序尺寸单位rpx

- 5.样式导入（WeUI for）

- 6.选择器

- 7.小程序image高度自适应及裁剪问题

- 8.微信小程序长按识别二维码

- 9.给页面加背景色

- 10.微信小程序获取用户信息

- 11.代码审核和发布

- 12.小程序微信认证

- 13.小程序申请微信支付

- 14.小程序的目录解构及四种文件类型

- 15.小程序文件的作用域

- 16.小程序常用组件

- - 1.view
  - 2.scroll-view
  - 3.swiper组件
  - 4.movable-view
  - 5.cover-view
  - 6.cover-image

**小程序基础**

- 17.授权得到用户信息

- 18.数据绑定

- 19.列表渲染

- 20.条件渲染

- 21.公共模板建立

- 22.事件及事件绑定

- 23.引用

- 24.页面跳转

- - 1.wx.switchTab
  - 2.wx.reLaunch
  - 3.wx.redirectTo
  - 4.wx.navigateTo
  - 5.wx.navigateBack

- 25.设置tabBar

- 26.页面生命周期

- 27.转发分享

**小程序高级**



- 28.request请求后台接口
- 29.http-promise 封装
- 30.webview
- 31.获取用户收货地址
- 32.获取地里位置
- 33.自定义组件
- 34.微信小程序支付问题

**小程序项目实战**

- 35.微信小程序本地数据缓存
- 36.下拉刷新和下拉加载
- 37.列表页向详情页跳转（动态修改title）
- 38.客服电话
- 39.星级评分组件
- 40.小程序插槽的使用slot
- 41.模糊查询
- 42.wxs过滤
- 43.小程序动画
- 44.列表根据索引值渲染
- 45.小程序动态修改class
- 46.小程序常用框架
- 47.参数传值的方法
- 48.提高小程序的应用速度
- 49.微信小程序的优劣势
- 50.小程序的双向绑定和vue的区别
- 51.微信小程序给按钮添加动画
- 52.微信小程序的tab按钮的转换
- 53.微信小程序引进echarts
- 54.APP打开小程序流程
- 55.小程序解析富文本编辑器

**小程序常见bug**

- 1.域名必须是HTTPS
- 2.input组件placeholder字体颜色
- 3.wx.navigateTo无法跳转到带tabbar的页面
- 4.tabbar在切换时页面数据无法刷新
- 5.如何去掉自定义button灰色的圆角边框
- 6.input textarea是APP的原生组件，z-index层级最高
- 7.一段文字如何换行
- 8.设置最外层标签的margin-bottom在IOS下不生效
- 9.小程序中canvas的图片不支持base64格式
- 10.回到页面顶部
- 11.wx.setStorageSync和wx.getStorageSync报错问题
- 12.如何获取微信群名称？
- 13.new Date跨平台兼容性问题
- 14.wx.getSystemInfoSync获取windowHeight不准确
- 15.图片本地资源名称，尽量使用小写命名



**移动端热点问题**

- px border问题
- 2.2X图 3X图适配
- 3.图片在安卓上，有些设备模糊问题
- 4.固定定位布局 键盘挡住输入框内容
- 5.click的300ms延迟问题和点击穿透问题
- 6.phone及ipad下输入框默认内阴影
- 7.防止手机中页面放大和缩小
- 8.flex布局
- 9.px、em、rem、%、vw、vh、vm这些单位的区别
- 10.移动端适配- dpr浅析
- 11.移动端扩展点击区域
- 12 上下拉动滚动条时卡顿、慢
- 13 长时间按住页面出现闪退
- 14.ios和android下触摸元素时出现半透明灰色遮罩
- 15.active兼容处理 即 伪类：active失效
- 16.webkit mask兼容处理
- 17.pc端与移动端字体大小的问题
- 18.transiton闪屏
- 19.圆角bug
- 20.如何解决禁用表单后移动端样式不统一问题 ?